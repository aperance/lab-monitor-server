// poll.js
// William Aperance
//
// Recursive function which constantly fetches state data from device at the specified IP address.
// State is received as a string, which requires parsing using eval. While use of eval is generally
// discouraged, the cons are not applicable in this use case. If fetch is successful, new fetch is made
// with received sequence key. This causes the device to wait until state changes before responding.
// If fetch timesout, retry will be attempted after configured interval. A retry count value is passed
// through recursive calls. Polling will end on error, of maxReries achived. Polling for this IP address
// will eventually be attempted again based on the watchList configuration.
//

// Exports factory function used for dependency injection.
exports.createPoll = (deviceStore, watchList, config, fetch) => {
  const poll = (ipAddress, sequence = 0, count = 0, status = "initial") => {
    // Extract necessary values from config object.
    const {
      fetch: { port, resource, sequenceKey },
      retryInterval,
      maxRetries
    } = config.polling;

    // Confirm that IP address is still in watchList. If false, return, ending polling cycle.
    // If true, continue. (watchList will also update its timestamp for this device).
    if (!watchList.check(ipAddress)) return;

    // Construct url from IP address and configuration parameters.
    let url = "http://" + ipAddress + ":" + port + resource;
    // Add query string with sequence key, if not 0
    url += "?" + sequenceKey + "=" + sequence;

    //console.log("Fetching " + url);

    // Fetch state data from device, using url and timeout value from config.
    fetch(url, { timeout: 60000 })
      // Extract string from response object.
      .then(res => res.text())
      // Parse result string, saving data to device store. Perform new poll,
      // with latest sequence key (if exists), resetting retry count to 0.
      .then(res => {
        const state = evalWrapper(res.replace("display(", "("));
        if (status !== "connected") console.log("Connection established with " + ipAddress);
        deviceStore.set(ipAddress, state);
        poll(ipAddress, state[sequenceKey] || 0, 0, "connected");
      })
      .catch(err => {
        if (err.type == "request-timeout") {
          console.log(ipAddress + " timed out. Restarting poll...");
          poll(ipAddress, 0, 0, "connected");
        }
        else {
          if (status === "connected") {
            console.log("Setting " + ipAddress + " as disconnected");
            deviceStore.setInactive(ipAddress);
          }
          if (err.code === "ETIMEDOUT" || "ECONNRESET" || "ECONNREFUSED") {
            if (status === "initial") console.log("No device detected at " + ipAddress + ". Exiting.")
            else {
              if (count >= maxRetries) console.log("Maximum retries attempted for " + ipAddress + ", stopping poll");
              else {
                console.log("Connection failed for " + ipAddress + "(Attempt " + count + ")");
                poll(ipAddress, 0, count + 1, "disconnected");
              }
            }
          }
          else if (err === "EvalError") console.log("Error parsing response from " + ipAddress);
          else console.log(err);
        }
      });

    // Wrapper function to catch errors parsing response string.
    const evalWrapper = x => {
      try {
        return eval(x);
      } catch (e) {
        throw new EvalError();
      }
    };
  };

  // Return function generated by factory function.
  return poll;
};

// poll.js
// William Aperance
//
// Recursive function which constantly fetches state data from device at the specified IP address.
// State is received as a string, which requires parsing using eval. While use of eval is generally
// discouraged, the cons are not applicable in this use case. If fetch is successful, new fetch is made
// with received sequence key. This causes the device to wait until state changes before responding.
// If fetch timesout, retry will be attempted after configured interval. A retry count value is passed
// through recursive calls. Polling will end on error, of maxReries achived. Polling for this IP address
// will eventually be attempted again based on the watchList configuration.
//

// Exports factory function used for dependency injection.
exports.createPoll = (deviceStore, watchList, config, fetch) => {
  const poll = (ipAddress, sequence = 0, count = 0, connectionStatus = false) => {
    // Extract necessary values from config object.
    const {
      fetch: { port, resource, sequenceKey },
      retryInterval,
      maxRetries
    } = config.polling;

    // Confirm that IP address is still in watchList. If false, return, ending polling cycle.
    // If true, continue. (watchList will also update its timestamp for this device).
    if (!watchList.check(ipAddress)) return;

    // Construct url from IP address and configuration parameters.
    let url = "http://" + ipAddress + ":" + port + resource;
    // Add query string with sequence key, if not 0
    url += "?" + sequenceKey + "=" + sequence;

    //console.log("Fetching " + url);

    // Fetch state data from device, using url and timeout value from config.
    fetch(url, { timeout: 60000 })
      // Extract string from response object.
      .then(res => res.text())
      // Parse result string, saving data to device store. Perform new poll,
      // with latest sequence key (if exists), resetting retry count to 0.
      .then(res => {
        const state = evalWrapper(res.replace("display(", "("));
        //console.log("Received state from " + ipAddress);
        deviceStore.set(ipAddress, state);
        poll(ipAddress, state[sequenceKey] || 0, 0, true);
      })
      .catch(err => {
        if (err.type == "request-timeout") {
          console.log(ipAddress + " timed out. Restarting poll...");
          poll(ipAddress, 0, 0, true);
        }
        else if (err.code === "ETIMEDOUT" || "ECONNRESET") {
          if (!connectionStatus) console.log("No connection established to " + ipAddress + ", stopping poll")
          else if (count >= maxRetries) console.log("Maximum retries attempted for " + ipAddress + ", stopping poll")
          else {
            if (count === 0) {
              console.log("Lost connection to " + ipAddress + ", setting inactive");
              deviceStore.setInactive(ipAddress);
            }
            else console.log("Reconnection failed for " + ipAddress + "(Attempt " + count + ")");
            // Retry polling after retryInterval. Reset sequence key to 0. Increment retry count.
            //setTimeout(poll, retryInterval, ipAddress, 0, count + 1, true);
            poll(ipAddress, 0, count + 1, true);
          }
        }
        else if (err.code === "ECONNREFUSED") console.log("Connection actively refused by " + ipAddress);
        else if (err === "EvalError") console.log("Error parsing response from " + ipAddress);
        else console.log(err);
      });

    // Wrapper function to catch errors parsing response string.
    const evalWrapper = x => {
      try {
        return eval(x);
      } catch (e) {
        throw new EvalError();
      }
    };
  };

  // Return function generated by factory function.
  return poll;
};

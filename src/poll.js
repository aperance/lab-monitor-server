// poll.js
// William Aperance
//
// Recursive function which constantly fetches state data from device at the specified IP address.
// State is received as a string, which requires parsing using eval. While use of eval is generally
// discouraged, the cons are not applicable in this use case. If fetch is successful, new fetch is made
// with received sequence key. This causes the device to wait until state changes before responding.
// If fetch timesout, retry will be attempted after configured interval. A retry count value is passed
// through recursive calls. Polling will end on error, of maxReries achived. Polling for this IP address
// will eventually be attempted again based on the watchList configuration.
//

// Exports factory function used for dependency injection.
exports.createPoll = (deviceStore, watchList, config, fetch) => {
  const poll = (ipAddress, sequence = 0, count = 0) => {
    // Extract necessary values from config object.
    const {
      fetch: { port, resource, sequenceKey, timeout },
      retryInterval,
      maxRetries
    } = config.polling;

    // Confirm that IP address is still in watchList. If false, return, ending polling cycle.
    // If true, continue. (watchList will also update its timestamp for this device).
    if (!watchList.check(ipAddress)) return;

    // Construct url from IP address and configuration parameters.
    let url = "http://" + ipAddress + ":" + port + resource;
    // Add query string with sequence key, if not 0
    url += "?" + sequenceKey + "=" + sequence;

    console.log("Fetching " + url);

    // Fetch state data from device, using url and timeout value from config.
    fetch(url, { timeout })
      // Extract string from response object.
      .then(res => res.text())
      // Parse result string, saving data to device store. Perform new poll,
      // with latest sequence key (if exists), resetting retry count to 0.
      .then(res => {
        const state = evalWrapper(res.replace("display(", "("));
        console.log("Received state from " + ipAddress);
        deviceStore.set(ipAddress, state);
        poll(ipAddress, state[sequenceKey] || 0, 0);
      })
      .catch(err => {
        // On timeout, if retry count is less that maxRetry setting, retry polling
        // after retryInterval. Reset sequence key to 0. Increment retry count.
        if (err.type == "request-timeout" || err.code =="ETIMEDOUT") {
          if (count < maxRetries) {
            console.log("No reponse received from " + ipAddress);
            setTimeout(poll, retryInterval, ipAddress, 0, count + 1);
          }
        }
        else if (err.code == "ECONNREFUSED") console.log("Connection actively refused by " + ipAddress);
        else if (err == "EvalError") console.log("Error parsing response from " + ipAddress);
        else console.log(err);
      });

    // Wrapper function to catch errors parsing response string.
    const evalWrapper = x => {
      try {
        return eval(x);
      } catch (e) {
        throw new EvalError();
      }
    };
  };

  // Return function generated by factory function.
  return poll;
};
